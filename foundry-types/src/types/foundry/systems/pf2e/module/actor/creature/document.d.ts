/// <reference types="jquery" resolution-mode="require"/>
import { ActorPF2e, type PartyPF2e } from "src/types/foundry/systems/pf2e/module/actor";
import { HitPointsSummary } from "src/types/foundry/systems/pf2e/module/actor/base.ts";
import { CreatureSource } from "src/types/foundry/systems/pf2e/module/actor/data/index.ts";
import { StatisticModifier } from "src/types/foundry/systems/pf2e/module/actor/modifiers.ts";
import { MovementType, SaveType, SkillLongForm } from "src/types/foundry/systems/pf2e/module/actor/types.ts";
import { ArmorPF2e, ItemPF2e, PhysicalItemPF2e } from "src/types/foundry/systems/pf2e/module/item";
import { ItemType } from "src/types/foundry/systems/pf2e/module/item/data/index.ts";
import { ItemCarryType } from "src/types/foundry/systems/pf2e/module/item/physical/data.ts";
import { ActiveEffectPF2e } from "src/types/foundry/systems/pf2e/module/active-effect.ts";
import { Rarity } from "src/types/foundry/systems/pf2e/module/data.ts";
import { RuleElementSynthetics } from "src/types/foundry/systems/pf2e/module/rules/index.ts";
import { UserPF2e } from "src/types/foundry/systems/pf2e/module/user/index.ts";
import type { TokenDocumentPF2e } from "src/types/foundry/systems/pf2e/module/scene/index.ts";
import type { CheckRoll } from "src/types/foundry/systems/pf2e/module/system/check/index.ts";
import type { ArmorStatistic } from "src/types/foundry/systems/pf2e/module/system/statistic/armor-class.ts";
import { Statistic, StatisticDifficultyClass } from "src/types/foundry/systems/pf2e/module/system/statistic/index.ts";
import { CreatureSkills, CreatureSpeeds, CreatureSystemData, LabeledSpeed, SenseData, VisionLevel } from "./data.ts";
import { CreatureSensePF2e } from "./sense.ts";
import { Alignment, CreatureTrait, CreatureUpdateContext, GetReachParameters } from "./types.ts";
/** An "actor" in a Pathfinder sense rather than a Foundry one: all should contain attributes and abilities */
export declare abstract class CreaturePF2e<TParent extends TokenDocumentPF2e | null = TokenDocumentPF2e | null> extends ActorPF2e<TParent> {
  parties: Set<PartyPF2e>;
  /** A creature always has an AC */
  armorClass: StatisticDifficultyClass<ArmorStatistic>;
  /** Skill checks for the creature, built during data prep */
  skills: CreatureSkills;
  /** Saving throw rolls for the creature, built during data prep */
  saves: Record<SaveType, Statistic>;
  perception: Statistic;
  /** The creature's position on the alignment axes */
  get alignment(): Alignment;
  get rarity(): Rarity;
  get allowedItemTypes(): (ItemType | "physical")[];
  /**
   * A currently naive measurement of this creature's reach
   * @param [context.action] The action context of the reach measurement. Interact actions don't consider weapons.
   * @param [context.weapon] The "weapon," literal or otherwise, used in an attack-reach measurement
   */
  getReach({ action, weapon }?: GetReachParameters): number;
  get visionLevel(): VisionLevel;
  get hasDarkvision(): boolean;
  get hasLowLightVision(): boolean;
  get canSee(): boolean;
  get canAct(): boolean;
  get canAttack(): boolean;
  get isDead(): boolean;
  /** Whether the creature emits sound: overridable by AE-like */
  get emitsSound(): boolean;
  get isSpellcaster(): boolean;
  get wornArmor(): ArmorPF2e<this> | null;
  /** Get the held shield of most use to the wielder */
  get heldShield(): ArmorPF2e<this> | null;
  getStatistic(slug: SaveType | SkillLongForm | "perception"): Statistic;
  getStatistic(slug: string): Statistic | null;
  protected _initialize(options?: Record<string, unknown>): void;
  prepareData(): void;
  /** Setup base ephemeral data to be modified by active effects and derived-data preparation */
  prepareBaseData(): void;
  prepareEmbeddedDocuments(): void;
  prepareDerivedData(): void;
  protected prepareSynthetics(): void;
  /**
   * Changes the carry type of an item (held/worn/stowed/etc) and/or regrips/reslots
   * @param item       The item
   * @param carryType  Location to be set to
   * @param handsHeld  Number of hands being held
   * @param inSlot     Whether the item is in the slot or not. Equivilent to "equipped" previously
   */
  adjustCarryType(
    item: PhysicalItemPF2e<CreaturePF2e>,
    {
      carryType,
      handsHeld,
      inSlot,
    }: {
      carryType: ItemCarryType;
      handsHeld?: number;
      inSlot?: boolean;
    }
  ): Promise<void>;
  /**
   * Adds a custom modifier that will be included when determining the final value of a stat. The slug generated by
   * the name parameter must be unique for the custom modifiers for the specified stat, or it will be ignored.
   */
  addCustomModifier(stat: string, label: string, value: number, type: string): Promise<void>;
  /** Removes a custom modifier by slug */
  removeCustomModifier(stat: string, slug: string): Promise<void>;
  /**
   * Roll a Recovery Check
   * Prompt the user for input regarding Advantage/Disadvantage and any Situational Bonus
   */
  rollRecovery(event: JQuery.TriggeredEvent): Promise<Rolled<CheckRoll> | null>;
  /** Prepare derived creature senses from Rules Element synthetics */
  prepareSenses(data: SenseData[], synthetics: RuleElementSynthetics): CreatureSensePF2e[];
  prepareSpeed(movementType: "land"): this["system"]["attributes"]["speed"];
  prepareSpeed(movementType: Exclude<MovementType, "land">): (LabeledSpeed & StatisticModifier) | null;
  prepareSpeed(movementType: MovementType): CreatureSpeeds | (LabeledSpeed & StatisticModifier) | null;
  /** Remove any features linked to a to-be-deleted ABC item */
  deleteEmbeddedDocuments(embeddedName: "ActiveEffect" | "Item", ids: string[], context?: DocumentModificationContext<this>): Promise<ActiveEffectPF2e<this>[] | ItemPF2e<this>[]>;
  protected _preUpdate(changed: DeepPartial<this["_source"]>, options: CreatureUpdateContext<TParent>, user: UserPF2e): Promise<boolean | void>;

  readonly _source: CreatureSource;
  system: CreatureSystemData;
  get traits(): Set<CreatureTrait>;
  get hitPoints(): HitPointsSummary;
  /** Expand DocumentModificationContext for creatures */
  update(data: DocumentUpdateData<this>, options?: CreatureUpdateContext<TParent>): Promise<this>;
  /** See implementation in class */
  updateEmbeddedDocuments(
    embeddedName: "ActiveEffect",
    updateData: EmbeddedDocumentUpdateData<ActiveEffectPF2e<this>>[],
    options?: DocumentUpdateContext<this>
  ): Promise<ActiveEffectPF2e<this>[]>;
  updateEmbeddedDocuments(embeddedName: "Item", updateData: EmbeddedDocumentUpdateData<ItemPF2e<this>>[], options?: DocumentUpdateContext<this>): Promise<ItemPF2e<this>[]>;
  updateEmbeddedDocuments(
    embeddedName: "ActiveEffect" | "Item",
    updateData: EmbeddedDocumentUpdateData<ActiveEffectPF2e<this> | ItemPF2e<this>>[],
    options?: DocumentUpdateContext<this>
  ): Promise<ActiveEffectPF2e<this>[] | ItemPF2e<this>[]>;
  deleteEmbeddedDocuments(embeddedName: "ActiveEffect", ids: string[], context?: DocumentModificationContext<this>): Promise<ActiveEffectPF2e<this>[]>;
  deleteEmbeddedDocuments(embeddedName: "Item", ids: string[], context?: DocumentModificationContext<this>): Promise<ItemPF2e<this>[]>;
  deleteEmbeddedDocuments(embeddedName: "ActiveEffect" | "Item", ids: string[], context?: DocumentModificationContext<this>): Promise<ActiveEffectPF2e<this>[] | ItemPF2e<this>[]>;
} 
